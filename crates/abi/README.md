# YXY C ABI

C-style yxy bindings for other language calls.

---

# Warning: Not actively maintained
Currently, all features(marked as `blocking`) are not enabled by default.

If there is some groundbreaking technology to efficiently run Rust `async` code across FFI boundaries, 
it may be considered for continued active maintenance. That would be great interesting :).

So, current efficient solution is to crate a asynchronous HTTP or RPC services to handle.
See [yxy-httpd].

[yxy-httpd]: https://github.com/DumpTime/yxy/tree/dev/crates/httpd

## Header
[include/yxy.h](include/yxy.h) (Generated by [`cbindgen`](https://github.com/eqrion/cbindgen))

### Manual
In the root of source tree:
```bash
rustup run nightly cbindgen --crate yxy-abi -c ./crates/abi/cbindgen.toml -o ./crates/abi/include/yxy.h
```

## Safety
1. Every pointer returned from rust side should be carefully freed by `destruct_` prefix function. e.g. using `destruct_c_string` to deallocate c-strings.
2. The program assumes that all input is valid. So any memory error is fatal and may causes program crashing!

## Examples

### Query electricity

```c
#include "yxy.h"

void query() {
  char *token = app_auth(UID);
  if (token == NULL) {
    printf("app auth failed.");
    return;
  }
  printf("token: %s\n", token);

  AppHandler *handler = build_app_handler(token);
  if (handler == NULL) {
    printf("build app handler failed.");
  }
  printf("handler: %p\n", handler);

  RoomInfo *bind = query_ele_bind(handler);
  if (bind == NULL) {
    printf("query bind info failed.");
  }
  printf("bind: %s\n", bind->room_code);

  ElectricityInfo *ele = query_ele(handler);
  if (ele == NULL) {
    printf("query ele info failed.");
  }
  printf("room: %s\nstatus: %s\ntotal surplus: %f %f\nsurplus: %f "
         "%f\nsubsidy: %f %f\n",
         ele->display_room_name, ele->room_status, ele->total_surplus,
         ele->total_amount, ele->surplus, ele->surplus_amount, ele->subsidy,
         ele->subsidy_amount);

  destruct_electricity_info(ele);
  destruct_c_string(token);
  destruct_room_info(bind);
  destruct_app_handler(handler);
}
```

### App login (query uid)

```c
#include "yxy.h"

void login() {
  LoginHandler *handler = new_login_handler();

  SecurityToken *st = get_security_token(handler);
  if (st == NULL) {
    printf("fail to get security token\n");
    return;
  }
  printf("security token: %s\nlevel: %d\n", st->token, st->level);

  int result;
  if (st->level != 0) {
    char *img = get_captcha_image(handler, st->token);
    printf("captcha img: %s\nplz input captcha code: ", img);
    char captcha[5] = {0};
    scanf("%s", captcha);
    destruct_c_string(img);

    result = send_verification_code(handler, PHONE_NUM, st->token, captcha);
  } else {
    result = send_verification_code(handler, PHONE_NUM, st->token, NULL);
  }

  if (result == 0 || result == 1) {
    printf("send verification code success\n");
  } else {
    printf("fail to send verification code: %d\n", result);
    return;
  }

  char code[7] = {0};

  printf("plz input verification code: ");
  scanf("%s", code);

  LoginInfo *li = do_login_by_code(handler, PHONE_NUM, code);

  if (li == NULL) {
    printf("fail to login\n");
    return;
  }
  printf("login success!\n");
  printf("uid: %s\ntoken: %s\ndivice_id: %s\nbind_card_status: %d\n", li->uid,
         li->token, li->device_id, li->bind_card_status);

  destruct_login_info(li);
  destruct_security_token(st);
  destruct_login_handler(handler);
}
```

## Error handling
Referred to the error handling in [`libgit2`](https://github.com/libgit2/libgit2/blob/main/docs/error-handling.md).

> `void` return values: If a function has a void return, then it will never fail. This primary will be used for object destructors.
> 
> `struct *` return values: These are simple accessor functions where the only meaningful error would typically be looking something up by index and having the index be out of bounds. In those cases, the function will typically return NULL.
> 
> `Boolean` return values: There are some cases where a function cannot fail and wants to return a boolean value. In those cases, we try to return 1 for true and 0 for false. These cases are rare and the return value for the function should probably be an unsigned int to denote these cases. If you find an exception, please open an issue and let's fix it.


By default, a null pointer is returned to indicate error.

Error code is returned in `c_int` from. The error is defined in `ErrorCode` enum. Likes:

```rust
#[repr(C)]
pub enum ErrorCode {
    /// No error
    OK = 0,

    /// Generic error
    ERROR = -1,

    /// Invalid inputs or operation
    EInvalid = -2,
    /// Authentication failed
    EAuth = -3,
    /// No bind info etc.
    ENoFound = -4,

    /// Bad phone number
    EPhoneNum = -10,
    /// Limit of SMS verification code sent
    ELimited = -11,
    /// Error verification code & captcha code
    EVeriCode = -12,
    /// Failed to get captcha image
    ECaptcha = -13,
}
```
